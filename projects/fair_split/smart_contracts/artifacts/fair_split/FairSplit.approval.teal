#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 100000
    bytecblock "contract_status" "spouse_1" "spouse_2" 0x00 "spouse_1_points" "spouse_2_points" "total_pool" "spouse_1_approved" "spouse_2_approved" 0x0006616374697665 "platform_address" 0x000e70656e64696e675f696e76697465 0x151f7c75 0x001270656e64696e675f7769746864726177616c "platform_fee_basis_points" 0x0021426f746820617070726f7665642e2046756e64732064697374726962757465642e
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/fair_split/contract.py:18
    // self.spouse_1 = Account()
    bytec_1 // "spouse_1"
    global ZeroAddress
    app_global_put
    // smart_contracts/fair_split/contract.py:19
    // self.spouse_2 = Account()
    bytec_2 // "spouse_2"
    global ZeroAddress
    app_global_put
    // smart_contracts/fair_split/contract.py:21
    // self.spouse_1_points = UInt64(0)
    bytec 4 // "spouse_1_points"
    intc_0 // 0
    app_global_put
    // smart_contracts/fair_split/contract.py:22
    // self.spouse_2_points = UInt64(0)
    bytec 5 // "spouse_2_points"
    intc_0 // 0
    app_global_put
    // smart_contracts/fair_split/contract.py:24
    // self.total_pool = UInt64(0)
    bytec 6 // "total_pool"
    intc_0 // 0
    app_global_put
    // smart_contracts/fair_split/contract.py:26
    // self.contract_status = arc4.String()
    bytec_0 // "contract_status"
    pushbytes 0x0000
    app_global_put
    // smart_contracts/fair_split/contract.py:28
    // self.spouse_1_approved = arc4.Bool(False)
    bytec 7 // "spouse_1_approved"
    bytec_3 // 0x00
    app_global_put
    // smart_contracts/fair_split/contract.py:29
    // self.spouse_2_approved = arc4.Bool(False)
    bytec 8 // "spouse_2_approved"
    // smart_contracts/fair_split/contract.py:28
    // self.spouse_1_approved = arc4.Bool(False)
    bytec_3 // 0x00
    // smart_contracts/fair_split/contract.py:29
    // self.spouse_2_approved = arc4.Bool(False)
    app_global_put
    // smart_contracts/fair_split/contract.py:31
    // self.platform_address = Account()
    bytec 10 // "platform_address"
    global ZeroAddress
    app_global_put
    // smart_contracts/fair_split/contract.py:32
    // self.platform_fee_basis_points = UInt64(650)  # 6.5%
    bytec 14 // "platform_fee_basis_points"
    pushint 650 // 650
    app_global_put

main_after_if_else@2:
    // smart_contracts/fair_split/contract.py:4
    // class FairSplit(ARC4Contract):
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@13
    pushbytess 0xedb2fc94 0x2368d4c2 0xaf720408 0x3424b0d7 0x4ac67e05 0x60e51f58 0x7b628de3 // method "invite_spouse(address)string", method "accept_invite()string", method "deposit(pay)string", method "request_withdrawal()string", method "approve_withdrawal()string", method "reject_withdrawal()string", method "get_contract_info()(string,address,address,uint64,uint64,uint64)"
    txna ApplicationArgs 0
    match invite_spouse accept_invite deposit request_withdrawal approve_withdrawal reject_withdrawal get_contract_info
    err

main_create_NoOp@13:
    // smart_contracts/fair_split/contract.py:4
    // class FairSplit(ARC4Contract):
    pushbytes 0xda6ac408 // method "create_contract()string"
    txna ApplicationArgs 0
    match create_contract
    err


// smart_contracts.fair_split.contract.FairSplit.create_contract[routing]() -> void:
create_contract:
    // smart_contracts/fair_split/contract.py:44
    // self.spouse_1 = Txn.sender
    bytec_1 // "spouse_1"
    txn Sender
    app_global_put
    // smart_contracts/fair_split/contract.py:45
    // self.spouse_2 = Global.zero_address
    bytec_2 // "spouse_2"
    global ZeroAddress
    app_global_put
    // smart_contracts/fair_split/contract.py:47
    // self.spouse_1_points = UInt64(0)
    bytec 4 // "spouse_1_points"
    intc_0 // 0
    app_global_put
    // smart_contracts/fair_split/contract.py:48
    // self.spouse_2_points = UInt64(0)
    bytec 5 // "spouse_2_points"
    intc_0 // 0
    app_global_put
    // smart_contracts/fair_split/contract.py:49
    // self.total_pool = UInt64(0)
    bytec 6 // "total_pool"
    intc_0 // 0
    app_global_put
    // smart_contracts/fair_split/contract.py:51
    // self.contract_status = arc4.String("pending_invite")
    bytec_0 // "contract_status"
    bytec 11 // 0x000e70656e64696e675f696e76697465
    app_global_put
    // smart_contracts/fair_split/contract.py:53
    // self.spouse_1_approved = arc4.Bool(False)
    bytec 7 // "spouse_1_approved"
    bytec_3 // 0x00
    app_global_put
    // smart_contracts/fair_split/contract.py:54
    // self.spouse_2_approved = arc4.Bool(False)
    bytec 8 // "spouse_2_approved"
    // smart_contracts/fair_split/contract.py:53
    // self.spouse_1_approved = arc4.Bool(False)
    bytec_3 // 0x00
    // smart_contracts/fair_split/contract.py:54
    // self.spouse_2_approved = arc4.Bool(False)
    app_global_put
    // smart_contracts/fair_split/contract.py:56-57
    // # Hardcoded platform address - receives 6.5% fee from all contracts
    // self.platform_address = Account(
    bytec 10 // "platform_address"
    // smart_contracts/fair_split/contract.py:56-58
    // # Hardcoded platform address - receives 6.5% fee from all contracts
    // self.platform_address = Account(
    //     "KO64H7YGWF6EEGP3EALQZTFR66UNYSRJLZOYGWGP5GTV2E4PBQDWFZNMIY")
    pushbytes base32(KO64H7YGWF6EEGP3EALQZTFR66UNYSRJLZOYGWGP5GTV2E4PBQDQ) // addr KO64H7YGWF6EEGP3EALQZTFR66UNYSRJLZOYGWGP5GTV2E4PBQDWFZNMIY
    app_global_put
    // smart_contracts/fair_split/contract.py:34
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    pushbytes 0x151f7c75002d436f6e747261637420637265617465642e205761697420666f722073706f75736520696e7669746174696f6e2e
    log
    intc_1 // 1
    return


// smart_contracts.fair_split.contract.FairSplit.invite_spouse[routing]() -> void:
invite_spouse:
    // smart_contracts/fair_split/contract.py:62
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/fair_split/contract.py:74
    // assert Txn.sender.bytes == self.spouse_1.bytes, "Only spouse 1 can invite"
    txn Sender
    intc_0 // 0
    bytec_1 // "spouse_1"
    app_global_get_ex
    assert // check self.spouse_1 exists
    swap
    dig 1
    ==
    assert // Only spouse 1 can invite
    // smart_contracts/fair_split/contract.py:76
    // assert self.contract_status == arc4.String(
    intc_0 // 0
    bytec_0 // "contract_status"
    app_global_get_ex
    assert // check self.contract_status exists
    // smart_contracts/fair_split/contract.py:76-77
    // assert self.contract_status == arc4.String(
    //     "pending_invite"), "Contract not in pending_invite state"
    bytec 11 // 0x000e70656e64696e675f696e76697465
    ==
    assert // Contract not in pending_invite state
    // smart_contracts/fair_split/contract.py:79
    // assert self.spouse_2.bytes == Global.zero_address.bytes, "Spouse 2 already invited"
    intc_0 // 0
    bytec_2 // "spouse_2"
    app_global_get_ex
    assert // check self.spouse_2 exists
    global ZeroAddress
    ==
    assert // Spouse 2 already invited
    // smart_contracts/fair_split/contract.py:81
    // assert spouse_address.bytes != self.spouse_1.bytes, "Cannot invite yourself"
    dig 1
    !=
    assert // Cannot invite yourself
    // smart_contracts/fair_split/contract.py:83
    // self.spouse_2 = spouse_address
    bytec_2 // "spouse_2"
    swap
    app_global_put
    // smart_contracts/fair_split/contract.py:62
    // @arc4.abimethod
    pushbytes 0x151f7c75002753706f75736520696e76697465642e2057616974696e6720666f7220616363657074616e63652e
    log
    intc_1 // 1
    return


// smart_contracts.fair_split.contract.FairSplit.accept_invite[routing]() -> void:
accept_invite:
    // smart_contracts/fair_split/contract.py:96
    // assert Txn.sender.bytes == self.spouse_2.bytes, "Only invited spouse can accept"
    txn Sender
    intc_0 // 0
    bytec_2 // "spouse_2"
    app_global_get_ex
    assert // check self.spouse_2 exists
    ==
    assert // Only invited spouse can accept
    // smart_contracts/fair_split/contract.py:98
    // assert self.contract_status == arc4.String(
    intc_0 // 0
    bytec_0 // "contract_status"
    app_global_get_ex
    assert // check self.contract_status exists
    // smart_contracts/fair_split/contract.py:98-99
    // assert self.contract_status == arc4.String(
    //     "pending_invite"), "Contract not in pending_invite state"
    bytec 11 // 0x000e70656e64696e675f696e76697465
    ==
    assert // Contract not in pending_invite state
    // smart_contracts/fair_split/contract.py:101
    // self.contract_status = arc4.String("active")
    bytec_0 // "contract_status"
    bytec 9 // 0x0006616374697665
    app_global_put
    // smart_contracts/fair_split/contract.py:87
    // @arc4.abimethod
    pushbytes 0x151f7c75002c496e7669746174696f6e2061636365707465642e20436f6e7472616374206973206e6f77206163746976652e
    log
    intc_1 // 1
    return


// smart_contracts.fair_split.contract.FairSplit.deposit[routing]() -> void:
deposit:
    pushbytes ""
    dupn 2
    // smart_contracts/fair_split/contract.py:105
    // @arc4.abimethod
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/fair_split/contract.py:122
    // assert self.contract_status == arc4.String(
    intc_0 // 0
    bytec_0 // "contract_status"
    app_global_get_ex
    assert // check self.contract_status exists
    // smart_contracts/fair_split/contract.py:122-123
    // assert self.contract_status == arc4.String(
    //     "active"), "Contract must be active"
    bytec 9 // 0x0006616374697665
    ==
    assert // Contract must be active
    // smart_contracts/fair_split/contract.py:125
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (
    txn Sender
    intc_0 // 0
    bytec_1 // "spouse_1"
    app_global_get_ex
    assert // check self.spouse_1 exists
    ==
    // smart_contracts/fair_split/contract.py:125-126
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (
    //     Txn.sender.bytes == self.spouse_2.bytes), "Only spouses can deposit"
    bnz deposit_bool_true@3
    // smart_contracts/fair_split/contract.py:126
    // Txn.sender.bytes == self.spouse_2.bytes), "Only spouses can deposit"
    txn Sender
    intc_0 // 0
    bytec_2 // "spouse_2"
    app_global_get_ex
    assert // check self.spouse_2 exists
    ==
    // smart_contracts/fair_split/contract.py:125-126
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (
    //     Txn.sender.bytes == self.spouse_2.bytes), "Only spouses can deposit"
    bz deposit_bool_false@4

deposit_bool_true@3:
    intc_1 // 1

deposit_bool_merge@5:
    // smart_contracts/fair_split/contract.py:125-126
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (
    //     Txn.sender.bytes == self.spouse_2.bytes), "Only spouses can deposit"
    assert // Only spouses can deposit
    // smart_contracts/fair_split/contract.py:128
    // assert payment.receiver == Global.current_application_address, "Payment must be to contract"
    dupn 2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must be to contract
    // smart_contracts/fair_split/contract.py:130
    // amount_micro = payment.amount
    gtxns Amount
    dup
    bury 4
    // smart_contracts/fair_split/contract.py:131
    // amount_algo = amount_micro // UInt64(1_000_000)
    pushint 1000000 // 1000000
    /
    dup
    bury 5
    // smart_contracts/fair_split/contract.py:156
    // if amount_algo < UInt64(5):
    pushint 5 // 5
    <
    bz deposit_else_body@11
    // smart_contracts/fair_split/contract.py:157
    // return UInt64(50)
    pushint 50 // 50
    bury 2

deposit_after_inlined_smart_contracts.fair_split.contract.FairSplit._calculate_points@14:
    // smart_contracts/fair_split/contract.py:135
    // self.total_pool += amount_micro
    intc_0 // 0
    bytec 6 // "total_pool"
    app_global_get_ex
    assert // check self.total_pool exists
    dig 3
    +
    bytec 6 // "total_pool"
    swap
    app_global_put
    // smart_contracts/fair_split/contract.py:137
    // if Txn.sender.bytes == self.spouse_1.bytes:
    txn Sender
    intc_0 // 0
    bytec_1 // "spouse_1"
    app_global_get_ex
    assert // check self.spouse_1 exists
    ==
    bz deposit_else_body@7
    // smart_contracts/fair_split/contract.py:138
    // self.spouse_1_points += points_earned
    intc_0 // 0
    bytec 4 // "spouse_1_points"
    app_global_get_ex
    assert // check self.spouse_1_points exists
    dig 2
    +
    bytec 4 // "spouse_1_points"
    swap
    app_global_put
    // smart_contracts/fair_split/contract.py:139
    // return arc4.String("Spouse 1 deposit success")
    pushbytes 0x001853706f7573652031206465706f7369742073756363657373

deposit_after_inlined_smart_contracts.fair_split.contract.FairSplit.deposit@8:
    // smart_contracts/fair_split/contract.py:105
    // @arc4.abimethod
    bytec 12 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

deposit_else_body@7:
    // smart_contracts/fair_split/contract.py:141
    // self.spouse_2_points += points_earned
    intc_0 // 0
    bytec 5 // "spouse_2_points"
    app_global_get_ex
    assert // check self.spouse_2_points exists
    dig 2
    +
    bytec 5 // "spouse_2_points"
    swap
    app_global_put
    // smart_contracts/fair_split/contract.py:142
    // return arc4.String("Spouse 2 deposit success")
    pushbytes 0x001853706f7573652032206465706f7369742073756363657373
    // smart_contracts/fair_split/contract.py:105
    // @arc4.abimethod
    b deposit_after_inlined_smart_contracts.fair_split.contract.FairSplit.deposit@8

deposit_else_body@11:
    // smart_contracts/fair_split/contract.py:158
    // elif amount_algo < UInt64(10):
    dig 3
    pushint 10 // 10
    <
    bz deposit_else_body@13
    // smart_contracts/fair_split/contract.py:159
    // return UInt64(75)
    pushint 75 // 75
    bury 2
    // smart_contracts/fair_split/contract.py:133
    // points_earned = self._calculate_points(amount_algo)
    b deposit_after_inlined_smart_contracts.fair_split.contract.FairSplit._calculate_points@14

deposit_else_body@13:
    // smart_contracts/fair_split/contract.py:161
    // return (amount_algo // UInt64(20)) * UInt64(100)
    dig 3
    pushint 20 // 20
    /
    pushint 100 // 100
    *
    bury 2
    // smart_contracts/fair_split/contract.py:133
    // points_earned = self._calculate_points(amount_algo)
    b deposit_after_inlined_smart_contracts.fair_split.contract.FairSplit._calculate_points@14

deposit_bool_false@4:
    intc_0 // 0
    b deposit_bool_merge@5


// smart_contracts.fair_split.contract.FairSplit.request_withdrawal[routing]() -> void:
request_withdrawal:
    // smart_contracts/fair_split/contract.py:173
    // assert self.contract_status == arc4.String(
    intc_0 // 0
    bytec_0 // "contract_status"
    app_global_get_ex
    assert // check self.contract_status exists
    // smart_contracts/fair_split/contract.py:173-174
    // assert self.contract_status == arc4.String(
    //     "active"), "Contract must be active"
    bytec 9 // 0x0006616374697665
    ==
    assert // Contract must be active
    // smart_contracts/fair_split/contract.py:176
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (Txn.sender.bytes ==
    txn Sender
    intc_0 // 0
    bytec_1 // "spouse_1"
    app_global_get_ex
    assert // check self.spouse_1 exists
    ==
    // smart_contracts/fair_split/contract.py:176-177
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (Txn.sender.bytes ==
    //                                                      self.spouse_2.bytes), "Only spouse can request withdrawal"
    bnz request_withdrawal_bool_true@3
    // smart_contracts/fair_split/contract.py:176
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (Txn.sender.bytes ==
    txn Sender
    // smart_contracts/fair_split/contract.py:177
    // self.spouse_2.bytes), "Only spouse can request withdrawal"
    intc_0 // 0
    bytec_2 // "spouse_2"
    app_global_get_ex
    assert // check self.spouse_2 exists
    // smart_contracts/fair_split/contract.py:176-177
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (Txn.sender.bytes ==
    //                                                      self.spouse_2.bytes), "Only spouse can request withdrawal"
    ==
    bz request_withdrawal_bool_false@4

request_withdrawal_bool_true@3:
    intc_1 // 1

request_withdrawal_bool_merge@5:
    // smart_contracts/fair_split/contract.py:176-177
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (Txn.sender.bytes ==
    //                                                      self.spouse_2.bytes), "Only spouse can request withdrawal"
    assert // Only spouse can request withdrawal
    // smart_contracts/fair_split/contract.py:179
    // self.contract_status = arc4.String("pending_withdrawal")
    bytec_0 // "contract_status"
    bytec 13 // 0x001270656e64696e675f7769746864726177616c
    app_global_put
    // smart_contracts/fair_split/contract.py:181
    // self.spouse_1_approved = arc4.Bool(False)
    bytec 7 // "spouse_1_approved"
    bytec_3 // 0x00
    app_global_put
    // smart_contracts/fair_split/contract.py:182
    // self.spouse_2_approved = arc4.Bool(False)
    bytec 8 // "spouse_2_approved"
    // smart_contracts/fair_split/contract.py:181
    // self.spouse_1_approved = arc4.Bool(False)
    bytec_3 // 0x00
    // smart_contracts/fair_split/contract.py:182
    // self.spouse_2_approved = arc4.Bool(False)
    app_global_put
    // smart_contracts/fair_split/contract.py:163
    // @arc4.abimethod
    pushbytes 0x151f7c7500305769746864726177616c207265717565737465642e20426f74682073706f75736573206d75737420617070726f76652e
    log
    intc_1 // 1
    return

request_withdrawal_bool_false@4:
    intc_0 // 0
    b request_withdrawal_bool_merge@5


// smart_contracts.fair_split.contract.FairSplit.approve_withdrawal[routing]() -> void:
approve_withdrawal:
    // smart_contracts/fair_split/contract.py:196
    // assert self.contract_status == arc4.String(
    intc_0 // 0
    bytec_0 // "contract_status"
    app_global_get_ex
    assert // check self.contract_status exists
    // smart_contracts/fair_split/contract.py:196-197
    // assert self.contract_status == arc4.String(
    //     "pending_withdrawal"), "No withdrawal pending"
    bytec 13 // 0x001270656e64696e675f7769746864726177616c
    ==
    assert // No withdrawal pending
    // smart_contracts/fair_split/contract.py:199
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (
    txn Sender
    intc_0 // 0
    bytec_1 // "spouse_1"
    app_global_get_ex
    assert // check self.spouse_1 exists
    ==
    // smart_contracts/fair_split/contract.py:199-200
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (
    //     Txn.sender.bytes == self.spouse_2.bytes), "Only spouses can approve"
    bnz approve_withdrawal_bool_true@3
    // smart_contracts/fair_split/contract.py:200
    // Txn.sender.bytes == self.spouse_2.bytes), "Only spouses can approve"
    txn Sender
    intc_0 // 0
    bytec_2 // "spouse_2"
    app_global_get_ex
    assert // check self.spouse_2 exists
    ==
    // smart_contracts/fair_split/contract.py:199-200
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (
    //     Txn.sender.bytes == self.spouse_2.bytes), "Only spouses can approve"
    bz approve_withdrawal_bool_false@4

approve_withdrawal_bool_true@3:
    intc_1 // 1

approve_withdrawal_bool_merge@5:
    // smart_contracts/fair_split/contract.py:199-200
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (
    //     Txn.sender.bytes == self.spouse_2.bytes), "Only spouses can approve"
    assert // Only spouses can approve
    // smart_contracts/fair_split/contract.py:202
    // if Txn.sender.bytes == self.spouse_1.bytes:
    txn Sender
    intc_0 // 0
    bytec_1 // "spouse_1"
    app_global_get_ex
    assert // check self.spouse_1 exists
    ==
    bz approve_withdrawal_else_body@9
    // smart_contracts/fair_split/contract.py:203
    // assert not self.spouse_1_approved.native, "Spouse 1 already approved"
    intc_0 // 0
    bytec 7 // "spouse_1_approved"
    app_global_get_ex
    assert // check self.spouse_1_approved exists
    intc_0 // 0
    getbit
    !
    assert // Spouse 1 already approved
    // smart_contracts/fair_split/contract.py:204
    // self.spouse_1_approved = arc4.Bool(True)
    bytec 7 // "spouse_1_approved"
    pushbytes 0x80
    app_global_put
    // smart_contracts/fair_split/contract.py:206
    // if self.spouse_2_approved.native:
    intc_0 // 0
    bytec 8 // "spouse_2_approved"
    app_global_get_ex
    assert // check self.spouse_2_approved exists
    intc_0 // 0
    getbit
    bz approve_withdrawal_else_body@8
    // smart_contracts/fair_split/contract.py:207
    // self._distribute_funds()
    callsub _distribute_funds
    // smart_contracts/fair_split/contract.py:208
    // return arc4.String("Both approved. Funds distributed.")
    bytec 15 // 0x0021426f746820617070726f7665642e2046756e64732064697374726962757465642e

approve_withdrawal_after_inlined_smart_contracts.fair_split.contract.FairSplit.approve_withdrawal@12:
    // smart_contracts/fair_split/contract.py:186
    // @arc4.abimethod
    bytec 12 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

approve_withdrawal_else_body@8:
    // smart_contracts/fair_split/contract.py:210
    // return arc4.String("Spouse 1 approved. Waiting for spouse 2.")
    pushbytes 0x002853706f757365203120617070726f7665642e2057616974696e6720666f722073706f75736520322e
    // smart_contracts/fair_split/contract.py:186
    // @arc4.abimethod
    b approve_withdrawal_after_inlined_smart_contracts.fair_split.contract.FairSplit.approve_withdrawal@12

approve_withdrawal_else_body@9:
    // smart_contracts/fair_split/contract.py:212
    // assert not self.spouse_2_approved.native, "Spouse 2 already approved"
    intc_0 // 0
    bytec 8 // "spouse_2_approved"
    app_global_get_ex
    assert // check self.spouse_2_approved exists
    intc_0 // 0
    getbit
    !
    assert // Spouse 2 already approved
    // smart_contracts/fair_split/contract.py:213
    // self.spouse_2_approved = arc4.Bool(True)
    bytec 8 // "spouse_2_approved"
    pushbytes 0x80
    app_global_put
    // smart_contracts/fair_split/contract.py:215
    // if self.spouse_1_approved.native:
    intc_0 // 0
    bytec 7 // "spouse_1_approved"
    app_global_get_ex
    assert // check self.spouse_1_approved exists
    intc_0 // 0
    getbit
    bz approve_withdrawal_else_body@11
    // smart_contracts/fair_split/contract.py:216
    // self._distribute_funds()
    callsub _distribute_funds
    // smart_contracts/fair_split/contract.py:217
    // return arc4.String("Both approved. Funds distributed.")
    bytec 15 // 0x0021426f746820617070726f7665642e2046756e64732064697374726962757465642e
    // smart_contracts/fair_split/contract.py:186
    // @arc4.abimethod
    b approve_withdrawal_after_inlined_smart_contracts.fair_split.contract.FairSplit.approve_withdrawal@12

approve_withdrawal_else_body@11:
    // smart_contracts/fair_split/contract.py:219
    // return arc4.String("Spouse 2 approved. Waiting for spouse 1.")
    pushbytes 0x002853706f757365203220617070726f7665642e2057616974696e6720666f722073706f75736520312e
    // smart_contracts/fair_split/contract.py:186
    // @arc4.abimethod
    b approve_withdrawal_after_inlined_smart_contracts.fair_split.contract.FairSplit.approve_withdrawal@12

approve_withdrawal_bool_false@4:
    intc_0 // 0
    b approve_withdrawal_bool_merge@5


// smart_contracts.fair_split.contract.FairSplit.reject_withdrawal[routing]() -> void:
reject_withdrawal:
    // smart_contracts/fair_split/contract.py:231
    // assert self.contract_status == arc4.String(
    intc_0 // 0
    bytec_0 // "contract_status"
    app_global_get_ex
    assert // check self.contract_status exists
    // smart_contracts/fair_split/contract.py:231-232
    // assert self.contract_status == arc4.String(
    //     "pending_withdrawal"), "No withdrawal pending"
    bytec 13 // 0x001270656e64696e675f7769746864726177616c
    ==
    assert // No withdrawal pending
    // smart_contracts/fair_split/contract.py:234
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (
    txn Sender
    intc_0 // 0
    bytec_1 // "spouse_1"
    app_global_get_ex
    assert // check self.spouse_1 exists
    ==
    // smart_contracts/fair_split/contract.py:234-235
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (
    //     Txn.sender.bytes == self.spouse_2.bytes), "Only spouses can reject"
    bnz reject_withdrawal_bool_true@3
    // smart_contracts/fair_split/contract.py:235
    // Txn.sender.bytes == self.spouse_2.bytes), "Only spouses can reject"
    txn Sender
    intc_0 // 0
    bytec_2 // "spouse_2"
    app_global_get_ex
    assert // check self.spouse_2 exists
    ==
    // smart_contracts/fair_split/contract.py:234-235
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (
    //     Txn.sender.bytes == self.spouse_2.bytes), "Only spouses can reject"
    bz reject_withdrawal_bool_false@4

reject_withdrawal_bool_true@3:
    intc_1 // 1

reject_withdrawal_bool_merge@5:
    // smart_contracts/fair_split/contract.py:234-235
    // assert (Txn.sender.bytes == self.spouse_1.bytes) or (
    //     Txn.sender.bytes == self.spouse_2.bytes), "Only spouses can reject"
    assert // Only spouses can reject
    // smart_contracts/fair_split/contract.py:237
    // self.contract_status = arc4.String("active")
    bytec_0 // "contract_status"
    bytec 9 // 0x0006616374697665
    app_global_put
    // smart_contracts/fair_split/contract.py:239
    // self.spouse_1_approved = arc4.Bool(False)
    bytec 7 // "spouse_1_approved"
    bytec_3 // 0x00
    app_global_put
    // smart_contracts/fair_split/contract.py:240
    // self.spouse_2_approved = arc4.Bool(False)
    bytec 8 // "spouse_2_approved"
    // smart_contracts/fair_split/contract.py:239
    // self.spouse_1_approved = arc4.Bool(False)
    bytec_3 // 0x00
    // smart_contracts/fair_split/contract.py:240
    // self.spouse_2_approved = arc4.Bool(False)
    app_global_put
    // smart_contracts/fair_split/contract.py:221
    // @arc4.abimethod
    pushbytes 0x151f7c75002e5769746864726177616c2072656a65637465642e20436f6e74726163742069732061637469766520616761696e2e
    log
    intc_1 // 1
    return

reject_withdrawal_bool_false@4:
    intc_0 // 0
    b reject_withdrawal_bool_merge@5


// smart_contracts.fair_split.contract.FairSplit.get_contract_info[routing]() -> void:
get_contract_info:
    // smart_contracts/fair_split/contract.py:309
    // self.contract_status,
    intc_0 // 0
    bytec_0 // "contract_status"
    app_global_get_ex
    assert // check self.contract_status exists
    // smart_contracts/fair_split/contract.py:310
    // arc4.Address(self.spouse_1),
    intc_0 // 0
    bytec_1 // "spouse_1"
    app_global_get_ex
    assert // check self.spouse_1 exists
    // smart_contracts/fair_split/contract.py:311
    // arc4.Address(self.spouse_2),
    intc_0 // 0
    bytec_2 // "spouse_2"
    app_global_get_ex
    assert // check self.spouse_2 exists
    // smart_contracts/fair_split/contract.py:312
    // arc4.UInt64(self.spouse_1_points),
    intc_0 // 0
    bytec 4 // "spouse_1_points"
    app_global_get_ex
    assert // check self.spouse_1_points exists
    itob
    // smart_contracts/fair_split/contract.py:313
    // arc4.UInt64(self.spouse_2_points),
    intc_0 // 0
    bytec 5 // "spouse_2_points"
    app_global_get_ex
    assert // check self.spouse_2_points exists
    itob
    // smart_contracts/fair_split/contract.py:314
    // arc4.UInt64(self.total_pool)
    intc_0 // 0
    bytec 6 // "total_pool"
    app_global_get_ex
    assert // check self.total_pool exists
    itob
    // smart_contracts/fair_split/contract.py:299
    // @arc4.abimethod
    pushbytes 0x005a
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    bytec 12 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.fair_split.contract.FairSplit._distribute_funds() -> void:
_distribute_funds:
    // smart_contracts/fair_split/contract.py:244-245
    // @subroutine
    // def _distribute_funds(self) -> None:
    proto 0 0
    // smart_contracts/fair_split/contract.py:252
    // total_points = self.spouse_1_points + self.spouse_2_points
    intc_0 // 0
    bytec 4 // "spouse_1_points"
    app_global_get_ex
    assert // check self.spouse_1_points exists
    intc_0 // 0
    bytec 5 // "spouse_2_points"
    app_global_get_ex
    assert // check self.spouse_2_points exists
    dig 1
    +
    // smart_contracts/fair_split/contract.py:254
    // assert total_points > UInt64(0), "No points to distribute"
    dup
    assert // No points to distribute
    // smart_contracts/fair_split/contract.py:259-260
    // # Calculate distributable pool after reserving minimum balance
    // distributable_pool = self.total_pool - min_balance
    intc_0 // 0
    bytec 6 // "total_pool"
    app_global_get_ex
    assert // check self.total_pool exists
    // smart_contracts/fair_split/contract.py:256-257
    // # Reserve minimum balance requirement (100,000 microAlgos = 0.1 ALGO)
    // min_balance = UInt64(100_000)
    intc_2 // 100000
    // smart_contracts/fair_split/contract.py:259-260
    // # Calculate distributable pool after reserving minimum balance
    // distributable_pool = self.total_pool - min_balance
    -
    // smart_contracts/fair_split/contract.py:263
    // self.platform_fee_basis_points) // UInt64(10_000)
    intc_0 // 0
    bytec 14 // "platform_fee_basis_points"
    app_global_get_ex
    assert // check self.platform_fee_basis_points exists
    // smart_contracts/fair_split/contract.py:262-263
    // platform_fee = (distributable_pool *
    //                 self.platform_fee_basis_points) // UInt64(10_000)
    dig 1
    *
    // smart_contracts/fair_split/contract.py:263
    // self.platform_fee_basis_points) // UInt64(10_000)
    pushint 10000 // 10000
    // smart_contracts/fair_split/contract.py:262-263
    // platform_fee = (distributable_pool *
    //                 self.platform_fee_basis_points) // UInt64(10_000)
    /
    dup
    cover 4
    // smart_contracts/fair_split/contract.py:265
    // distributable_amount = distributable_pool - platform_fee
    swap
    dig 1
    -
    // smart_contracts/fair_split/contract.py:267-268
    // spouse_1_share = (distributable_amount *
    //                   self.spouse_1_points) // total_points
    dup
    uncover 4
    *
    uncover 3
    /
    dup
    cover 3
    // smart_contracts/fair_split/contract.py:269
    // spouse_2_share = distributable_amount - spouse_1_share
    -
    swap
    // smart_contracts/fair_split/contract.py:271
    // if platform_fee > UInt64(0):
    bz _distribute_funds_after_if_else@3
    // smart_contracts/fair_split/contract.py:272-276
    // itxn.Payment(
    //     receiver=self.platform_address,
    //     amount=platform_fee,
    //     fee=UInt64(0)
    // ).submit()
    itxn_begin
    // smart_contracts/fair_split/contract.py:273
    // receiver=self.platform_address,
    intc_0 // 0
    bytec 10 // "platform_address"
    app_global_get_ex
    assert // check self.platform_address exists
    frame_dig 0
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/fair_split/contract.py:272
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/fair_split/contract.py:275
    // fee=UInt64(0)
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/fair_split/contract.py:272-276
    // itxn.Payment(
    //     receiver=self.platform_address,
    //     amount=platform_fee,
    //     fee=UInt64(0)
    // ).submit()
    itxn_submit

_distribute_funds_after_if_else@3:
    // smart_contracts/fair_split/contract.py:278
    // if spouse_1_share > UInt64(0):
    frame_dig 1
    bz _distribute_funds_after_if_else@6
    // smart_contracts/fair_split/contract.py:279-283
    // itxn.Payment(
    //     receiver=self.spouse_1,
    //     amount=spouse_1_share,
    //     fee=UInt64(0),
    // ).submit()
    itxn_begin
    // smart_contracts/fair_split/contract.py:280
    // receiver=self.spouse_1,
    intc_0 // 0
    bytec_1 // "spouse_1"
    app_global_get_ex
    assert // check self.spouse_1 exists
    frame_dig 1
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/fair_split/contract.py:279
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/fair_split/contract.py:282
    // fee=UInt64(0),
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/fair_split/contract.py:279-283
    // itxn.Payment(
    //     receiver=self.spouse_1,
    //     amount=spouse_1_share,
    //     fee=UInt64(0),
    // ).submit()
    itxn_submit

_distribute_funds_after_if_else@6:
    // smart_contracts/fair_split/contract.py:285
    // if spouse_2_share > UInt64(0):
    frame_dig 2
    bz _distribute_funds_after_if_else@9
    // smart_contracts/fair_split/contract.py:286-290
    // itxn.Payment(
    //     receiver=self.spouse_2,
    //     amount=spouse_2_share,
    //     fee=UInt64(0),
    // ).submit()
    itxn_begin
    // smart_contracts/fair_split/contract.py:287
    // receiver=self.spouse_2,
    intc_0 // 0
    bytec_2 // "spouse_2"
    app_global_get_ex
    assert // check self.spouse_2 exists
    frame_dig 2
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/fair_split/contract.py:286
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/fair_split/contract.py:289
    // fee=UInt64(0),
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/fair_split/contract.py:286-290
    // itxn.Payment(
    //     receiver=self.spouse_2,
    //     amount=spouse_2_share,
    //     fee=UInt64(0),
    // ).submit()
    itxn_submit

_distribute_funds_after_if_else@9:
    // smart_contracts/fair_split/contract.py:292
    // self.contract_status = arc4.String("completed")
    bytec_0 // "contract_status"
    pushbytes 0x0009636f6d706c65746564
    app_global_put
    // smart_contracts/fair_split/contract.py:294-295
    // # Keep minimum balance in contract, reset points
    // self.total_pool = min_balance
    bytec 6 // "total_pool"
    // smart_contracts/fair_split/contract.py:256-257
    // # Reserve minimum balance requirement (100,000 microAlgos = 0.1 ALGO)
    // min_balance = UInt64(100_000)
    intc_2 // 100000
    // smart_contracts/fair_split/contract.py:294-295
    // # Keep minimum balance in contract, reset points
    // self.total_pool = min_balance
    app_global_put
    // smart_contracts/fair_split/contract.py:296
    // self.spouse_1_points = UInt64(0)
    bytec 4 // "spouse_1_points"
    intc_0 // 0
    app_global_put
    // smart_contracts/fair_split/contract.py:297
    // self.spouse_2_points = UInt64(0)
    bytec 5 // "spouse_2_points"
    intc_0 // 0
    app_global_put
    retsub
